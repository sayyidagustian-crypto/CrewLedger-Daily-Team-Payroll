/**
 * jsPDF-AutoTable version 3.8.2
 * Copyright (c) 2023 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable.
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 *
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('jspdf')) :
    typeof define === 'function' && define.amd ? define(['exports', 'jspdf'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jspdfAutotable = {}, global.jspdf));
})(this, (function (exports, jspdf) { 'use strict';

    var CellHookData = /** @class */ (function () {
        function CellHookData(cell, row, column, doc) {
            this.cell = cell;
            this.row = row;
            this.column = column;
            this.doc = doc;
            this.styles = cell.styles;
            this.text = cell.text;
            this.x = cell.x;
            this.y = cell.y;
            this.width = cell.width;
            this.height = cell.height;
            this.section = row.section;
        }
        return CellHookData;
    }());

    var HookData = /** @class */ (function () {
        function HookData(doc, table, cursor) {
            this.table = table;
            this.pageNumber = table.pageNumber;
            this.pageCount = this.pageNumber;
            this.settings = table.settings;
            this.cursor = cursor;
            this.doc = doc;
        }
        return HookData;
    }());
    var PageHookData = /** @class */ (function (_super) {
        __extends(PageHookData, _super);
        function PageHookData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return PageHookData;
    }(HookData));

    /**
     * Ratio between font size and font height. The number comes from jspdf's source code
     */
    var FONT_ROW_RATIO = 1.15;
    // Base two logarithms
    function getlog2(x) {
        if (Math.log2) {
            return Math.log2(x);
        }
        return Math.log(x) / Math.log(2);
    }
    function allRows(table) {
        return table.head.concat(table.body).concat(table.foot);
    }
    function fprivate(key) {
        return "_" + key;
    }
    function getFillStyle(styles) {
        var style = styles.fillColor;
        if (style === 'inherit') {
            return null;
        }
        if (Array.isArray(style)) {
            // Workaround for https://github.com/simonbengtsson/jsPDF-AutoTable/issues/623
            // TODO find a better solution. Maybe a doc setting that is true by default
            // that this check is removed. Or convert the user input to rgb.
            return style.slice(0, 3);
        }
        return style;
    }
    function addTableBorder(doc, table, startPos, pageContent) {
        var settings = table.settings;
        var margin = settings.margin;
        var tableLineColor = settings.tableLineColor, tableLineWidth = settings.tableLineWidth;
        if (tableLineWidth == null || tableLineColor == null)
            return;
        doc.setLineWidth(tableLineWidth);
        doc.setDrawColor(tableLineColor);
        var tableX = margin.left;
        var tableY = startPos.y;
        var tableWidth = pageContent.width;
        var tableHeight = 0;
        for (var _i = 0, _a = pageContent.rows; _i < _a.length; _i++) {
            var row = _a[_i];
            tableHeight += row.height;
        }
        doc.rect(tableX, tableY, tableWidth, tableHeight);
    }
    function addPage(doc, table, cursor) {
        callPageHooks(doc, table, table.hooks.addPage, cursor);
        table.pageNumber++;
        doc.addPage();
        table.pageStartX = cursor.x;
        table.pageStartY = cursor.y;
        cursor.x = table.settings.margin.left;
        cursor.y = table.settings.margin.top;
        callPageHooks(doc, table, table.hooks.afterNewPage, cursor);
    }
    function callPageHooks(doc, table, hooks, cursor) {
        for (var _i = 0, hooks_1 = hooks; _i < hooks_1.length; _i++) {
            var hook = hooks_1[_i];
            hook(new PageHookData(doc, table, cursor));
        }
    }
    function canFitOnPage(doc, row, cursorY, table) {
        var bottomContentHeight = table.settings.margin.bottom;
        var pageContentHeight = doc.internal.pageSize.height - cursorY - bottomContentHeight;
        if (row.maxLineCount > 1) {
            // For recognize the issue that the max line count of a row is greater than the page height,
            // we have to use Math.floor to get the correct integer.
            var pageHeight = doc.internal.pageSize.height;
            var margin = table.settings.margin;
            var verticalMargin = margin.top + margin.bottom;
            if (row.height > pageHeight - verticalMargin) {
                // Here is a check for the issue that a single cell needs to be split once or more.
                // We have to remove the after-split part of the row height from the total row height.
                // But we have to consider that the font size may be different in each column.
                var rowHeightWithoutExtraLines = (row.maxLineCount - 1) *
                    row.styles.fontSize *
                    FONT_ROW_RATIO *
                    table.scaleFactor;
                pageContentHeight += rowHeightWithoutExtraLines;
                pageContentHeight = Math.floor(pageContentHeight);
            }
        }
        return row.height <= pageContentHeight;
    }

    var document$1;
    function getDocument() {
        return document$1;
    }
    function setDocument(doc) {
        document$1 = doc;
    }
    // A variable to keep track of the state of the thick-border logic.
    var thickEdge = null;
    function applyStyles(styles) {
        var doc = getDocument();
        var styleModifiers = {
            fillColor: doc.setFillColor,
            textColor: doc.setTextColor,
            fontStyle: doc.setFontStyle,
            lineColor: doc.setDrawColor,
            lineWidth: doc.setLineWidth,
            font: doc.setFont,
            fontSize: doc.setFontSize,
        };
        for (var _i = 0, _a = Object.keys(styles); _i < _a.length; _i++) {
            var style = _a[_i];
            var value = styles[style];
            var modifier = styleModifiers[style];
            if (modifier) {
                if (Array.isArray(value)) {
                    modifier.apply(this, value);
                }
                else {
                    modifier(value);
                }
            }
        }
    }
    // This is a special style that is not part of the doc options.
    // It is used to draw thicker lines between cells.
    function lineWidth(width) {
        getDocument().setLineWidth(width);
    }
    function thickEdgeLineColor(color) {
        if (color) {
            getDocument().setDrawColor(color);
        }
    }
    function drawLine(x1, y1, x2, y2, styles, borders) {
        if (!borders) {
            borders = 'B';
        }
        var B = borders.includes('B');
        var F = borders.includes('F');
        var L = borders.includes('L');
        var T = borders.includes('T');
        var R = borders.includes('R');
        var doc = getDocument();
        var defaultLineWidth = doc.getLineWidth();
        var minMax = function (a, b) { return (a > b ? [b, a] : [a, b]); };
        var lineColors = {
            top: styles.topLineColor,
            left: styles.leftLineColor,
            bottom: styles.bottomLineColor,
            right: styles.rightLineColor,
        };
        var lineWidths = {
            top: styles.topLineWidth,
            left: styles.leftLineWidth,
            bottom: styles.bottomLineWidth,
            right: styles.rightLineWidth,
        };
        var drawLineWrapper = function (x1, y1, x2, y2, color, width) {
            if (width > 0) {
                doc.setLineWidth(width);
                doc.setDrawColor(color);
                doc.line(x1, y1, x2, y2, 'S');
            }
        };
        var _a = minMax(x1, x2), bx1 = _a[0], bx2 = _a[1];
        var _b = minMax(y1, y2), by1 = _b[0], by2 = _b[1];
        if (F || T) {
            drawLineWrapper(bx1, by1, bx2, by1, lineColors.top, lineWidths.top);
        }
        if (F || B) {
            drawLineWrapper(bx1, by2, bx2, by2, lineColors.bottom, lineWidths.bottom);
        }
        if (F || L) {
            drawLineWrapper(bx1, by1, bx1, by2, lineColors.left, lineWidths.left);
        }
        if (F || R) {
            drawLineWrapper(bx2, by1, bx2, by2, lineColors.right, lineWidths.right);
        }
        // Reset line width and color
        doc.setLineWidth(defaultLineWidth);
        doc.setDrawColor(styles.lineColor);
    }
    function drawBorders(cell, options) {
        var doc = getDocument();
        var defaultLineWidth = doc.getLineWidth();
        var _a = cell.borders, B = _a.B, F = _a.F, L = _a.L, T = _a.T, R = _a.R;
        var _b = cell.x, x = _b === void 0 ? 0 : _b, _c = cell.y, y = _c === void 0 ? 0 : _c, _d = cell.width, width = _d === void 0 ? 0 : _d, _e = cell.height, height = _e === void 0 ? 0 : _e;
        var styles = cell.styles;
        var drawLineWrapper = function (x1, y1, x2, y2, color, width) {
            if (width > 0) {
                if (thickEdge && thickEdge.x1 === x1 && thickEdge.y1 === y1) {
                    // This line has already been drawn by a previous cell.
                    // This is to avoid drawing the same line twice.
                    return;
                }
                if (thickEdge && thickEdge.x2 === x2 && thickEdge.y2 === y2) {
                    // This line has already been drawn by a previous cell.
                    // This is to avoid drawing the same line twice.
                    return;
                }
                var newThickEdge = {
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                    width: width,
                    color: color,
                };
                if (thickEdge && thickEdge.width > newThickEdge.width) {
                    // The other cell has a thicker border, so we let that cell
                    // draw it.
                    return;
                }
                else if (thickEdge && thickEdge.width < newThickEdge.width) {
                    // This cell has a thicker border, so we draw it.
                    thickEdge = newThickEdge;
                }
                else if (thickEdge && thickEdge.width === newThickEdge.width) {
                    // The other cell has the same border width, so we let the
                    // first cell draw it.
                    return;
                }
                else {
                    thickEdge = newThickEdge;
                }
            }
        };
        var lineColors = {
            top: styles.topLineColor,
            left: styles.leftLineColor,
            bottom: styles.bottomLineColor,
            right: styles.rightLineColor,
        };
        var lineWidths = {
            top: styles.topLineWidth,
            left: styles.leftLineWidth,
            bottom: styles.bottomLineWidth,
            right: styles.rightLineWidth,
        };
        if (options === null || options === void 0 ? void 0 : options.start) {
            // Reset the thick edge logic.
            thickEdge = null;
        }
        if (F || T) {
            drawLineWrapper(x, y, x + width, y, lineColors.top, lineWidths.top);
        }
        if (F || B) {
            drawLineWrapper(x, y + height, x + width, y + height, lineColors.bottom, lineWidths.bottom);
        }
        if (F || L) {
            drawLineWrapper(x, y, x, y + height, lineColors.left, lineWidths.left);
        }
        if (F || R) {
            drawLineWrapper(x + width, y, x + width, y + height, lineColors.right, lineWidths.right);
        }
        if (options === null || options === void 0 ? void 0 : options.end) {
            if (thickEdge) {
                // Draw the thick edge.
                lineWidth(thickEdge.width);
                thickEdgeLineColor(thickEdge.color);
                doc.line(thickEdge.x1, thickEdge.y1, thickEdge.x2, thickEdge.y2, 'S');
            }
        }
        // Reset line width and color
        doc.setLineWidth(defaultLineWidth);
        doc.setDrawColor(styles.lineColor);
    }

    // `input` has to be a non-null object.
    function parseCss(supportedFonts, input, scaleFactor) {
        var result = {};
        var pxScaleFactor = 96 / 72;
        var fontSize = -1;
        var _loop_1 = function (key) {
            var value = input[key];
            if (value === undefined) {
                return "continue";
            }
            switch (key) {
                case 'font-family':
                case 'fontFamily':
                    if (supportedFonts.indexOf(value.toLowerCase()) !== -1) {
                        result.font = value;
                    }
                    else {
                        // Font is not supported, ignore
                    }
                    break;
                case 'font-style':
                case 'fontStyle':
                    if (['normal', 'italic', 'oblique'].indexOf(value) !== -1) {
                        result.fontStyle = value;
                    }
                    break;
                case 'font-weight':
                case 'fontWeight':
                    if (['normal', 'bold', '700'].indexOf(value) !== -1 ||
                        /^[1-9]00$/.test(value)) {
                        if (value === 'bold' || value === 700 || value === '700') {
                            value = 'bold';
                        }
                        else {
                            // The other values are not supported by jsPDF, use normal
                            value = 'normal';
                        }
                        result.fontStyle = result.fontStyle
                            ? result.fontStyle + value
                            : value;
                    }
                    break;
                case 'font-size':
                case 'fontSize':
                    fontSize = parseFontSize(value, -1);
                    break;
            }
        };
        for (var _i = 0, _a = Object.keys(input); _i < _a.length; _i++) {
            var key = _a[_i];
            _loop_1(key);
        }
        // In css the font size is related to the font height, but in jspdf it is related to the font width.
        // We need to convert the font size to the font width.
        result.fontSize = fontSize / scaleFactor;
        if (result.fontSize < 0) {
            // If the font size is not set, we use the doc font size.
            delete result.fontSize;
        }
        var _loop_2 = function (key) {
            var value = input[key];
            if (value === undefined) {
                return "continue";
            }
            switch (key) {
                case 'line-height':
                case 'lineHeight':
                    result.lineHeightFactor =
                        parseFontSize(value, result.fontSize) /
                            (result.fontSize || 12);
                    break;
                case 'text-align':
                case 'textAlign':
                    result.align = value;
                    break;
                case 'vertical-align':
                case 'verticalAlign':
                    result.valign = value;
                    break;
                case 'color':
                    result.textColor = value;
                    break;
                case 'background-color':
                case 'backgroundColor':
                    result.fillColor = value;
                    break;
                case 'padding':
                    {
                        var paddings = Array.isArray(value)
                            ? value
                            : [value];
                        var top_1 = -1;
                        var right = -1;
                        var bottom = -1;
                        var left = -1;
                        for (var i = 0; i < paddings.length; i++) {
                            var p = parsePadding(paddings[i] || 0, -1);
                            if (p < 0)
                                continue;
                            if (i === 0) {
                                top_1 = right = bottom = left = p;
                            }
                            else if (i === 1) {
                                right = left = p;
                            }
                            else if (i === 2) {
                                bottom = p;
                            }
                            else if (i === 3) {
                                left = p;
                            }
                            else {
                                // More than 4 paddings are not supported
                                break;
                            }
                        }
                        result.cellPadding = {
                            top: top_1,
                            right: right,
                            bottom: bottom,
                            left: left,
                        };
                    }
                    break;
                case 'padding-top':
                case 'paddingTop':
                    {
                        var padding = parsePadding(value, -1);
                        if (padding >= 0) {
                            if (typeof result.cellPadding !== 'object') {
                                result.cellPadding = {};
                            }
                            result.cellPadding.top = padding;
                        }
                    }
                    break;
                case 'padding-right':
                case 'paddingRight':
                    {
                        var padding = parsePadding(value, -1);
                        if (padding >= 0) {
                            if (typeof result.cellPadding !== 'object') {
                                result.cellPadding = {};
                            }
                            result.cellPadding.right = padding;
                        }
                    }
                    break;
                case 'padding-bottom':
                case 'paddingBottom':
                    {
                        var padding = parsePadding(value, -1);
                        if (padding >= 0) {
                            if (typeof result.cellPadding !== 'object') {
                                result.cellPadding = {};
                            }
                            result.cellPadding.bottom = padding;
                        }
                    }
                    break;
                case 'padding-left':
                case 'paddingLeft':
                    {
                        var padding = parsePadding(value, -1);
                        if (padding >= 0) {
                            if (typeof result.cellPadding !== 'object') {
                                result.cellPadding = {};
                            }
                            result.cellPadding.left = padding;
                        }
                    }
                    break;
                case 'border':
                    {
                        var borders = (Array.isArray(value)
                            ? value
                            : [value]);
                        if (borders.length === 0) {
                            borders.push(null);
                        }
                        for (var _i = 0, borders_1 = borders; _i < borders_1.length; _i++) {
                            var border = borders_1[_i];
                            var width = parseBorderWidth(border);
                            if (width < 0) {
                                continue;
                            }
                            result.lineWidth = width;
                            break;
                        }
                    }
                    break;
                case 'border-top':
                case 'borderTop':
                    {
                        var width = parseBorderWidth(value);
                        if (width < 0) {
                            break;
                        }
                        result.topLineWidth = width;
                        var color = parseBorderColor(value);
                        if (color) {
                            result.topLineColor = color;
                        }
                    }
                    break;
                case 'border-right':
                case 'borderRight':
                    {
                        var width = parseBorderWidth(value);
                        if (width < 0) {
                            break;
                        }
                        result.rightLineWidth = width;
                        var color = parseBorderColor(value);
                        if (color) {
                            result.rightLineColor = color;
                        }
                    }
                    break;
                case 'border-bottom':
                case 'borderBottom':
                    {
                        var width = parseBorderWidth(value);
                        if (width < 0) {
                            break;
                        }
                        result.bottomLineWidth = width;
                        var color = parseBorderColor(value);
                        if (color) {
                            result.bottomLineColor = color;
                        }
                    }
                    break;
                case 'border-left':
                case 'borderLeft':
                    {
                        var width = parseBorderWidth(value);
if (width < 0) {
                            break;
                        }
                        result.leftLineWidth = width;
                        var color = parseBorderColor(value);
                        if (color) {
                            result.leftLineColor = color;
                        }
                    }
                    break;
                case 'border-color':
                case 'borderColor':
                    {
                        var colors = (Array.isArray(value)
                            ? value
                            : [value]);
                        if (colors.length === 0) {
                            colors.push(null);
                        }
                        var top_2 = null;
                        var right = null;
                        var bottom = null;
                        var left = null;
                        for (var i = 0; i < colors.length; i++) {
                            var c = colors[i];
                            if (!c)
                                continue;
                            if (i === 0) {
                                top_2 = right = bottom = left = c;
                            }
                            else if (i === 1) {
                                right = left = c;
                            }
                            else if (i === 2) {
                                bottom = c;
                            }
                            else if (i === 3) {
                                left = c;
                            }
                            else {
                                // More than 4 colors are not supported
                                break;
                            }
                        }
                        if (top_2) {
                            result.topLineColor = top_2;
                        }
                        if (right) {
                            result.rightLineColor = right;
                        }
                        if (bottom) {
                            result.bottomLineColor = bottom;
                        }
                        if (left) {
                            result.leftLineColor = left;
                        }
                    }
                    break;
                case 'border-top-color':
                case 'borderTopColor':
                    result.topLineColor = value;
                    break;
                case 'border-right-color':
                case 'borderRightColor':
                    result.rightLineColor = value;
                    break;
                case 'border-bottom-color':
                case 'borderBottomColor':
                    result.bottomLineColor = value;
                    break;
                case 'border-left-color':
                case 'borderLeftColor':
                    result.leftLineColor = value;
                    break;
                case 'border-width':
                case 'borderWidth':
                    {
                        var widths = (Array.isArray(value)
                            ? value
                            : [value]);
                        if (widths.length === 0) {
                            widths.push(0);
                        }
                        var top_3 = -1;
                        var right = -1;
                        var bottom = -1;
                        var left = -1;
                        for (var i = 0; i < widths.length; i++) {
                            var w = parseBorderWidth(widths[i], -1);
                            if (w < 0)
                                continue;
                            if (i === 0) {
                                top_3 = right = bottom = left = w;
                            }
                            else if (i === 1) {
                                right = left = w;
                            }
                            else if (i === 2) {
                                bottom = w;
                            }
                            else if (i === 3) {
                                left = w;
                            }
                            else {
                                // More than 4 widths are not supported
                                break;
                            }
                        }
                        if (top_3 >= 0) {
                            result.topLineWidth = top_3;
                        }
                        if (right >= 0) {
                            result.rightLineWidth = right;
                        }
                        if (bottom >= 0) {
                            result.bottomLineWidth = bottom;
                        }
                        if (left >= 0) {
                            result.leftLineWidth = left;
                        }
                    }
                    break;
                case 'border-top-width':
                case 'borderTopWidth':
                    {
                        var width = parseBorderWidth(value, -1);
                        if (width >= 0) {
                            result.topLineWidth = width;
                        }
                    }
                    break;
                case 'border-right-width':
                case 'borderRightWidth':
                    {
                        var width = parseBorderWidth(value, -1);
                        if (width >= 0) {
                            result.rightLineWidth = width;
                        }
                    }
                    break;
                case 'border-bottom-width':
                case 'borderBottomWidth':
                    {
                        var width = parseBorderWidth(value, -1);
                        if (width >= 0) {
                            result.bottomLineWidth = width;
                        }
                    }
                    break;
                case 'border-left-width':
                case 'borderLeftWidth':
                    {
                        var width = parseBorderWidth(value, -1);
                        if (width >= 0) {
                            result.leftLineWidth = width;
                        }
                    }
                    break;
                case 'min-cell-height':
                case 'minCellHeight':
                    {
                        var height = parsePadding(value, -1);
                        if (height >= 0) {
                            result.minCellHeight = height;
                        }
                    }
                    break;
                case 'min-cell-width':
                case 'minCellWidth':
                    {
                        var width = parsePadding(value, -1);
                        if (width >= 0) {
                            result.minCellWidth = width;
                        }
                    }
                    break;
                case 'cell-width':
                case 'cellWidth':
                    {
                        var width = parsePadding(value, -1);
                        if (width >= 0) {
                            result.cellWidth = width;
                        }
                    }
                    break;
                case 'word-break':
                case 'wordBreak':
                    if (value === 'break-all' || value === 'break-word') {
                        result.wordBreak = value;
                    }
                    break;
                case 'overflow':
                    if (typeof result.overflow === 'undefined') {
                        result.overflow = value;
                    }
                    break;
            }
        };
        for (var _b = 0, _c = Object.keys(input); _b < _c.length; _b++) {
            var key = _c[_b];
            _loop_2(key);
        }
        function parseBorderWidth(value, fallBack) {
            if (fallBack === void 0) { fallBack = 0; }
            if (!value) {
                return fallBack;
            }
            if (typeof value === 'number') {
                return value;
            }
            if (typeof value !== 'string') {
                return fallBack;
            }
            // check if the value is a number
            if (/^\d+(\.\d+)?(px|pt)?$/.test(value)) {
                var res = parseFloat(value);
                if (value.indexOf('px') !== -1) {
                    res *= pxScaleFactor;
                }
                return res;
            }
            // check for thin, medium, thick
            if (value === 'thin') {
                return 0.5;
            }
            if (value === 'medium') {
                return 1;
            }
            if (value === 'thick') {
                return 2;
            }
            return fallBack;
        }
        function parseBorderColor(value) {
            if (typeof value !== 'string') {
                return null;
            }
            // find a color in the string
            var regex = /(rgba?\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})(,\s*([\d.]+))?\))|(#[a-fA-F0-9]{3,8})|([a-zA-Z]+)/g;
            var match = regex.exec(value);
            if (match) {
                return match[0];
            }
            return null;
        }
        function parsePadding(value, fallBack) {
            if (fallBack === void 0) { fallBack = 0; }
            if (typeof value === 'number') {
                return value;
            }
            if (typeof value !== 'string') {
                return fallBack;
            }
            if (/^\d+(\.\d+)?(px|pt)?$/.test(value)) {
                var res = parseFloat(value);
                if (value.indexOf('px') !== -1) {
                    res *= pxScaleFactor;
                }
                return res;
            }
            return fallBack;
        }
        function parseFontSize(value, fallBack) {
            if (fallBack === void 0) { fallBack = 0; }
            if (typeof value === 'number') {
                return value;
            }
            if (typeof value !== 'string') {
                return fallBack;
            }
            if (value.indexOf('px') !== -1) {
                return parseFloat(value) * pxScaleFactor;
            }
            if (value.indexOf('pt') !== -1) {
                return parseFloat(value);
            }
            return fallBack;
        }
        return result;
    }

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var defaults = {
        // Styling
        theme: 'striped',
        styles: {},
        headStyles: {},
        bodyStyles: {},
        footStyles: {},
        alternateRowStyles: {},
        columnStyles: {},
        // Properties
        useCss: false,
        // Deprecated, use pageBreak = 'always'
        continueNewPage: false,
        pageBreak: 'auto',
        rowPageBreak: 'auto',
        showHead: 'everyPage',
        showFoot: 'everyPage',
        tableWidth: 'auto',
        // Hooks
        didParseCell: function (data) { },
        willDrawCell: function (data) { },
        didDrawCell: function (data) { },
        didDrawPage: function (data) { },
    };
    function getSettings(userOptions) {
        var settings = __assign(__assign({}, defaults), userOptions);
        // Merge styles
        var _loop_1 = function (styles) {
            if (settings[styles] && typeof settings[styles] !== 'object') {
                console.error('The "' +
                    styles +
                    '" style should be an object, removing it from options.');
                delete settings[styles];
            }
            else if (settings[styles] && settings[styles].rowHeight) {
                console.warn('rowHeight style is deprecated since v3.0, use minCellHeight instead.');
            }
        };
        for (var _i = 0, _a = [
            'styles',
            'headStyles',
            'bodyStyles',
            'footStyles',
            'alternateRowStyles',
        ]; _i < _a.length; _i++) {
            var styles = _a[_i];
            _loop_1(styles);
        }
        var columnStyles = settings.columnStyles;
        if (columnStyles && typeof columnStyles !== 'object') {
            console.error('The "columnStyles" style should be an object, removing it from options.');
            delete settings.columnStyles;
        }
        return settings;
    }
    /**
     * @param css an object with css styles. For example {color: "red", "font-size": 20}
     * @returns an object with the styles that are supported by jspdf and this plugin
     */
    function parseCssStyles(css, doc) {
        var result = {};
        if (doc) {
            var supportedFonts = Object.keys(doc.getFontList());
            var scaleFactor = doc.internal.scaleFactor;
            result = parseCss(supportedFonts, css, scaleFactor);
        }

        return result;
    }
    // This is the default theme, which is also used as a base for all other themes
    function defaultStyles(scaleFactor) {
        return {
            font: 'helvetica',
            fontStyle: 'normal',
            overflow: 'linebreak',
            fillColor: false,
            textColor: 20,
            halign: 'left',
            valign: 'top',
            fontSize: 10,
            cellPadding: 5 / scaleFactor,
            lineColor: 200,
            lineWidth: 0,
            topLineWidth: 0,
            bottomLineWidth: 0.1 / scaleFactor,
            leftLineWidth: 0,
            rightLineWidth: 0,
            topLineColor: 200,
            bottomLineColor: 200,
            leftLineColor: 200,
            rightLineColor: 200,
            cellWidth: 'auto',
            minCellHeight: 0,
            minCellWidth: 0,
            wordBreak: 'normal',
        };
    }
    function getTheme(name, doc) {
        var themes = {
            striped: {
                table: {
                    fillColor: 255,
                    textColor: 80,
                    fontStyle: 'normal',
                },
                head: {
                    textColor: 255,
                    fillColor: [41, 128, 185],
                    fontStyle: 'bold',
                },
                body: {},
                foot: {
                    textColor: 255,
                    fillColor: [41, 128, 185],
                    fontStyle: 'bold',
                },
                alternateRow: { fillColor: 245 },
            },
            grid: {
                table: {
                    fillColor: 255,
                    textColor: 80,
                    fontStyle: 'normal',
                    lineWidth: 0.1,
                    lineColor: 180,
                },
                head: {
                    textColor: 255,
                    fillColor: [26, 188, 156],
                    fontStyle: 'bold',
                    lineWidth: 0,
                },
                body: {},
                foot: {
                    textColor: 255,
                    fillColor: [26, 188, 156],
                    fontStyle: 'bold',
                    lineWidth: 0,
                },
                alternateRow: {},
            },
            plain: {
                head: { fontStyle: 'bold' },
                foot: { fontStyle: 'bold' },
            },
        };
        var theme = themes[name];
        if (!theme) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var win = window;
            if (win &&
                win.autoTableHtmlToJson &&
                typeof win.autoTableHtmlToJson === 'function') {
                // Backwards compatibility for plugins etc
                var _a = win.autoTableHtmlToJson(null, true) || {}, _b = _a.theme, htmlTheme = _b === void 0 ? {} : _b, _c = _a.scaleFactor, sf = _c === void 0 ? 1 : _c;
                if (htmlTheme &&
                    htmlTheme[name] &&
                    typeof htmlTheme[name] === 'object') {
                    var newTheme = htmlTheme[name];
                    var styles = [
                        'table',
                        'head',
                        'body',
                        'foot',
                        'alternateRow',
                    ];
                    for (var _i = 0, styles_1 = styles; _i < styles_1.length; _i++) {
                        var style = styles_1[_i];
                        if (newTheme[style] && typeof newTheme[style] === 'object') {
                            newTheme[style] = parseCssStyles(newTheme[style], doc);
                        }
                    }
                    if (sf && doc) {
                        var scaleFactor_1 = doc.internal.scaleFactor;
                        for (var _d = 0, _e = Object.values(newTheme); _d < _e.length; _d++) {
                            var style = _e[_d];
                            if (typeof style !== 'object') {
                                continue;
                            }
                            if (style.fontSize) {
                                style.fontSize = style.fontSize / scaleFactor_1;
                            }
                            if (style.cellPadding) {
                                style.cellPadding = style.cellPadding / scaleFactor_1;
                            }
                            if (style.lineWidth) {
                                style.lineWidth = style.lineWidth / scaleFactor_1;
                            }
                        }
                    }
                    return newTheme;
                }
            }
        }
        return theme;
    }
    // Make sure that the line width defaults are not changed application wide
    function getStyles(styles, doc) {
        var scaleFactor = doc.internal.scaleFactor;
        var result = {};
        for (var _i = 0, styles_2 = styles; _i < styles_2.length; _i++) {
            var style = styles_2[_i];
            var styleValue = style;
            if (styleValue == null)
                continue;
            if (typeof styleValue !== 'object') {
                console.error('Styles should be an object, got ' + typeof styleValue + ' instead');
                continue;
            }
            if (styleValue.cellPadding &&
                typeof styleValue.cellPadding !== 'object') {
                var padding = styleValue.cellPadding;
                delete styleValue.cellPadding;
                styleValue.cellPadding = {
                    top: padding,
                    right: padding,
                    bottom: padding,
                    left: padding,
                };
            }
            // Move deprecated styles
            if (styleValue.columnWidth) {
                console.error('Use of deprecated style columnWidth, use cellWidth instead.');
                if (styleValue.cellWidth == null) {
                    styleValue.cellWidth = styleValue.columnWidth;
                }
            }
            if (styleValue.fontStyle && styleValue.fontStyle.includes('bold')) {
                styleValue.fontStyle = styleValue.fontStyle.replace('bold', '');
                if (!styleValue.font) {
                    // This is to support the deprecated fontStyle: 'bold'
                    styleValue.font = 'helvetica';
                }
            }
            // Support deprecated FONT_ROW_RATIO
            if (styleValue.rowHeight) {
                console.warn('rowHeight style is deprecated, use minCellHeight instead.');
                if (styleValue.minCellHeight == null) {
                    styleValue.minCellHeight =
                        (styleValue.rowHeight /
                            (styleValue.fontSize || defaultStyles(scaleFactor).fontSize)) *
                            scaleFactor *
                            FONT_ROW_RATIO;
                }
            }
            result = __assign(__assign({}, result), styleValue);
        }
        return result;
    }

    var Column = /** @class */ (function () {
        function Column(dataKey, raw, index) {
            this.dataKey = dataKey;
            this.raw = raw;
            this.index = index;
            this.wrappedWidth = 0;
            this.minReadableWidth = 0;
            this.minWidth = 0;
            this.width = 0;
        }
        Column.prototype.getMaxCustomCellWidth = function (table) {
            var max = 0;
            for (var _i = 0, _a = table.allRows(); _i < _a.length; _i++) {
                var row = _a[_i];
                var cell = row.cells[this.index];
                if (cell && typeof cell.styles.cellWidth === 'number') {
                    max = Math.max(max, cell.styles.cellWidth);
                }
            }
            return max;
        };
        return Column;
    }());

    var Table = /** @class */ (function () {
        function Table(id, settings, hooks, head, body, foot, columns) {
            this.id = id;
            this.settings = settings;
            this.hooks = hooks;
            this.head = head;
            this.body = body;
            this.foot = foot;
            this.columns = columns;
            this.pageNumber = 1;
            this.pageStartX = 0;
            this.pageStartY = 0;
            this.allRows = function () {
                return this.head.concat(this.body).concat(this.foot);
            };
        }
        Object.defineProperty(Table.prototype, "scaleFactor", {
            get: function () {
                return getDocument().internal.scaleFactor;
            },
            enumerable: false,
            configurable: true
        });
        Table.prototype.getHeadHeight = function (columns) {
            return this.head.reduce(function (acc, row) { return acc + row.getHeight(columns); }, 0);
        };
        Table.prototype.getFootHeight = function (columns) {
            return this.foot.reduce(function (acc, row) { return acc + row.getHeight(columns); }, 0);
        };
        return Table;
    }());

    var Row = /** @class */ (function () {
        function Row(raw, index, section, cells, spans) {
            this.raw = raw;
            this.index = index;
            this.section = section;
            this.cells = cells;
            this.spans = spans;
            this.height = 0;
            this.maxLineCount = 1;
            this.x = 0;
            this.y = 0;
        }
        Row.prototype.getHeight = function (columns) {
            var _this = this;
            var height = 0;
            columns.forEach(function (col) {
                var cell = _this.cells[col.index];
                if (cell && !cell.spanned) {
                    var h = cell.height;
                    if (h > height) {
                        height = h;
                    }
                }
            });
            return height;
        };
        return Row;
    }());

    var Cell = /** @class */ (function () {
        function Cell(raw, styles, section) {
            var _a, _b, _c, _d, _e;
            this.raw = raw;
            this.styles = styles;
            this.section = section;
            this.text = '';
            this.contentWidth = 0;
            this.textPos = {};
            this.height = 0;
            this.width = 0;
            this.x = 0;
            this.y = 0;
            this.colSpan = 1;
            this.rowSpan = 1;
            this.spanned = false;
            // A bit ugly, but it's the only way to get the borders to work
            this.borders = {
                // F = full, B = bottom, T = top, L = left, R = right
                F: false,
                B: false,
                T: false,
                L: false,
                R: false,
            };
            this.padding = function (part) {
                var padding = this.styles.cellPadding;
                if (Array.isArray(padding)) {
                    return padding;
                }
                else if (typeof padding === 'number') {
                    return { top: padding, right: padding, bottom: padding, left: padding };
                }
                else {
                    var top_1 = (_a = padding.top) !== null && _a !== void 0 ? _a : 0;
                    var right = (_b = padding.right) !== null && _b !== void 0 ? _b : 0;
                    var bottom = (_c = padding.bottom) !== null && _c !== void 0 ? _c : 0;
                    var left = (_d = padding.left) !== null && _d !== void 0 ? _d : 0;
                    if (part === 'vertical') {
                        return top_1 + bottom;
                    }
                    if (part === 'horizontal') {
                        return left + right;
                    }
                    return { top: top_1, right: right, bottom: bottom, left: left };
                }
            };
            this.colSpan = raw.colSpan || raw.colspan || 1;
            this.rowSpan = raw.rowSpan || raw.rowspan || 1;
            var _f = this.styles, T = _f.topLineWidth, R = _f.rightLineWidth, B = _f.bottomLineWidth, L = _f.leftLineWidth;
            if (T > 0 && R > 0 && B > 0 && L > 0) {
                this.borders.F = true;
            }
            if (T > 0 && !this.borders.F) {
                this.borders.T = true;
            }
            if (B > 0 && !this.borders.F) {
                this.borders.B = true;
            }
            if (L > 0 && !this.borders.F) {
                this.borders.L = true;
            }
            if (R > 0 && !this.borders.F) {
                this.borders.R = true;
            }
            var text = '';
            var rawValue = (_e = raw.content) !== null && _e !== void 0 ? _e : (raw.title || raw.dataKey || '');
            var multipleTexts = Array.isArray(rawValue) ? rawValue : [rawValue];
            this.text = multipleTexts
                .map(function (text) {
                var _a;
                return (_a = text === null || text === void 0 ? void 0 : text.toString()) !== null && _a !== void 0 ? _a : '';
            })
                .join('\n');
        }
        return Cell;
    }());

    var state = null;
    function getGlobal() {
        return state;
    }
    function getDoc() {
        return state.doc;
    }
    function setGlobal(newState) {
        state = newState;
    }
    var State = /** @class */ (function () {
        function State(doc) {
            this.doc = doc;
            this.userStyles = {
                // Black for versions of jspdf without getTextColor
                textColor: doc.getTextColor ? doc.getTextColor() : 0,
                fontSize: doc.getFontSize(),
                fontStyle: doc.getFont().fontStyle,
                font: doc.getFont().fontName,
            };
        }
        return State;
    }());
    function setupState(doc) {
        setGlobal(new State(doc));
    }
    function resetState() {
        setGlobal(null);
    }
    function setLastTable(table) {
        if (state)
            state.lastTable = table;
    }
    function getLastTable() {
        var _a;
        return (_a = state === null || state === void 0 ? void 0 : state.lastTable) !== null && _a !== void 0 ? _a : null;
    }

    function addContent(doc, table, cursor, pageContent) {
        var settings = table.settings;
        var startY = cursor.y;
        if (settings.showHead === 'firstPage' || settings.showHead === 'everyPage') {
            table.head.forEach(function (row) { return printRow(doc, table, row, cursor); });
        }
        table.body.forEach(function (row, index) {
            var isLast = index === table.body.length - 1;
            printFullRow(doc, table, row, isLast, cursor);
        });
        if (settings.showFoot === 'lastPage' || settings.showFoot === 'everyPage') {
            table.foot.forEach(function (row) { return printRow(doc, table, row, cursor); });
        }
        addTableBorder(doc, table, { y: startY }, pageContent);
        var _a = table.hooks, didDrawPage = _a.didDrawPage;
        callPageHooks(doc, table, didDrawPage, cursor);
    }
    function printFullRow(doc, table, row, isLast, cursor) {
        var newPage = false;
        var firstRowOnPage = false;
        var pageContent = getPageContent(table);
        if (!canFitOnPage(doc, row, cursor.y, table)) {
            // Determine if the passed row has content that can be vertically split.
            var hasSplittableContent = false;
            for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {
                var column = _a[_i];
                var cell = row.cells[column.index];
                if (cell) {
                    var text = Array.isArray(cell.text) ? cell.text : [];
                    // A cell can be split if it contains more than one line of text.
                    if (text.length > 1) {
                        hasSplittableContent = true;
                        break;
                    }
                }
            }
            if (hasSplittableContent) {
                // When the row cannot fit on one page, but has splittable content, we split the row and render the parts on two separate pages.
                var splittedRow = splitRow(row, table, doc);
                printRow(doc, table, splittedRow.row1, cursor);
                addPage(doc, table, cursor);
                firstRowOnPage = true;
                row = splittedRow.row2;
                newPage = true;
            }
            else {
                // When the row cannot fit on one page, and we cannot split it, we render the row on a new page.
                addPage(doc, table, cursor);
                firstRowOnPage = true;
            }
        }
        printRow(doc, table, row, cursor);
        if (settingsNeedNewPage(isLast, table.settings)) {
            addPage(doc, table, cursor);
            newPage = true;
        }
        if (table.settings.pageBreak === 'always') {
            addPage(doc, table, cursor);
            newPage = true;
        }
        // If the row is the last row on the page, and the user wants to draw the foot on the last page, we do that.
        var settings = table.settings;
        var onEveryPage = settings.showFoot === 'everyPage';
        var onLastPage = settings.showFoot === 'lastPage' && (isLast || firstRowOnPage);
        if (onEveryPage || onLastPage) {
            table.foot.forEach(function (row) { return printRow(doc, table, row, cursor); });
        }
        // If the user wants to draw the head on every page, we do that.
        // We do not do this if the row is the last row on the page, and the user wants to draw the foot on the last page.
        // This is to avoid drawing the head on a new page, and then the foot on the same page.
        var onEveryPageAgain = table.settings.showHead === 'everyPage' && !isLast;
        if (newPage && onEveryPageAgain) {
            table.head.forEach(function (row) { return printRow(doc, table, row, cursor); });
        }
    }
    /**
     * Standard algorithm for splitting a row vertically into two rows.
     */
    function splitRow(row, table, doc) {
        var row1 = new Row(row.raw, row.index, row.section, {}, new Map());
        var row2 = new Row(row.raw, row.index, row.section, {}, new Map());
        var maxLines = 0;
        // The idea is to have a row that is as high as the content that can fit on the current page,
        // and a row that is as high as the content that needs to be moved to the next page.
        for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {
            var column = _a[_i];
            var cell = row.cells[column.index];
            if (!cell)
                continue;
            var text = cell.text, styles = cell.styles;
            var cell1 = new Cell(cell.raw, styles, cell.section);
            var cell2 = new Cell(cell.raw, styles, cell.section);
            // Splitting the text is the most important part of this function.
            // We need to determine how many lines of text can fit on the current page,
            // and how many lines of text need to be moved to the next page.
            var pageHeight = doc.internal.pageSize.height;
            var margin = table.settings.margin;
            var verticalMargin = margin.top + margin.bottom;

            var availablePageHeight = pageHeight - verticalMargin;
            var remainingPageHeight = availablePageHeight - cell.y;
            var fontHeight = styles.fontSize * FONT_ROW_RATIO * table.scaleFactor;
            var M = Math.floor(remainingPageHeight / fontHeight);
            if (Array.isArray(text)) {
                var N_1 = text.length;
                if (M < N_1) {
                    // There is not enough space for the whole cell on the current page.
                    // We need to split the cell into two cells.
                    cell1.text = text.slice(0, M);
                    cell2.text = text.slice(M);
                    // We need to keep track of the maximum number of lines in a cell,
                    // so we can set the height of the row correctly.
                    if (cell2.text.length > maxLines) {
                        maxLines = cell2.text.length;
                    }
                }
                else {
                    // There is enough space for the whole cell on the current page.
                    cell1.text = text;
                    cell2.text = [];
                }
            }
            row1.cells[column.index] = cell1;
            row2.cells[column.index] = cell2;
        }
        // We need to set the height of the rows correctly.
        for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {
            var column = _c[_b];
            var cell1 = row1.cells[column.index];
            var cell2 = row2.cells[column.index];
            if (!cell1 || !cell2)
                continue;
            // The height of a cell is the number of lines of text in it multiplied by the font height.
            var fontHeight = cell1.styles.fontSize * FONT_ROW_RATIO * table.scaleFactor;
            cell1.height = cell1.text.length * fontHeight;
            cell2.height = cell2.text.length * fontHeight;
            // The height of a row is the maximum height of all the cells in it.
            if (cell1.height > row1.height) {
                row1.height = cell1.height;
            }
            if (cell2.height > row2.height) {
                row2.height = cell2.height;
            }
        }
        row1.maxLineCount = row1.height / (row1.styles.fontSize * FONT_ROW_RATIO * table.scaleFactor);
        row2.maxLineCount = row2.height / (row2.styles.fontSize * FONT_ROW_RATIO * table.scaleFactor);
        return { row1: row1, row2: row2 };
    }
    function printRow(doc, table, row, cursor) {
        row.x = table.settings.margin.left;
        row.y = cursor.y;
        var _loop_1 = function (column) {
            var cell = row.cells[column.index];
            if (!cell) {
                return "continue";
            }
            applyStyles(cell.styles);
            cell.x = row.x;
            cell.y = row.y;
            var hooks = table.hooks;
            if (hooks.willDrawCell(new CellHookData(cell, row, column, doc)) === false) {
                row.x += column.width;
                return "continue";
            }
            var fillStyle = getFillStyle(cell.styles);
            if (fillStyle) {
                doc.rect(cell.x, cell.y, cell.width, row.height, 'F');
            }
            var i = 0;
            drawBorders(cell, { start: true });
            for (var _i = 0, _a = cell.text; _i < _a.length; _i++) {
                var line = _a[_i];
                var halign = cell.styles.halign;
                var valign = cell.styles.valign;
                var x = cell.textPos.x;
                var y = cell.textPos.y + i * cell.styles.fontSize * FONT_ROW_RATIO;
                var lineBreaks = getlog2(line.length - 1);
                var isLineBreak = (cell.styles.overflow === 'linebreak' && line.length > 1) ||
                    (Array.isArray(cell.text) && i > 0);
                if (isLineBreak) {
                    y += cell.styles.fontSize * FONT_ROW_RATIO;
                }
                var text = line;
                var FONT_ROW_RATIO_1 = 1.15;
                if (valign === 'top') {
                    // Default
                }
                else if (valign === 'bottom') {
                    y += row.height - cell.text.length * cell.styles.fontSize * FONT_ROW_RATIO_1;
                }
                else if (valign === 'middle') {
                    y +=
                        row.height / 2 -
                            (cell.text.length * cell.styles.fontSize * FONT_ROW_RATIO_1) / 2;
                }
                if (halign === 'right') {
                    x += cell.width - cell.padding('horizontal');
                }
                else if (halign === 'center') {
                    x += cell.width / 2;
                }
                // Write text to doc
                var textOptions = {
                    align: halign,
                    baseline: valign,
                    maxWidth: cell.contentWidth,
                };
                doc.text(text, x, y, textOptions);
                i++;
            }
            hooks.didDrawCell(new CellHookData(cell, row, column, doc));
            row.x += column.width;
        };
        for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {
            var column = _a[_i];
            _loop_1(column);
        }
        var i = 0;
        for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {
            var column = _c[_b];
            var cell = row.cells[column.index];
            if (!cell) {
                continue;
            }
            drawBorders(cell, {
                start: i === 0,
                end: i === table.columns.length - 1,
            });
            i++;
        }
        cursor.y += row.height;
    }
    function settingsNeedNewPage(isLast, settings) {
        var newPage = false;
        if (settings.pageBreak === 'avoid' && !isLast) {
            newPage = true;
        }
        else if (settings.rowPageBreak === 'avoid' && !isLast) {
            // Deprecated TODO remove in next major
            console.warn('rowPageBreak is deprecated, use pageBreak with the value `avoid` instead');
            newPage = true;
        }
        return newPage;
    }
    function getPageContent(table) {
        var pageContent = {
            height: 0,
            width: 0,
            rows: [],
        };
        for (var _i = 0, _a = table.allRows(); _i < _a.length; _i++) {
            var row = _a[_i];
            pageContent.rows.push(row);
        }
        for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {
            var column = _c[_b];
            pageContent.width += column.width;
        }
        return pageContent;
    }

    function parseSpacing(value, defaultVal) {
        var _a, _b, _c, _d;
        var res = {};
        if (Array.isArray(value)) {
            if (value.length >= 4) {
                res = {
                    top: value[0],
                    right: value[1],
                    bottom: value[2],
                    left: value[3],
                };
            }
            else if (value.length === 3) {
                res = {
                    top: value[0],
                    right: value[1],
                    bottom: value[2],
                    left: value[1],
                };
            }
            else if (value.length === 2) {
                res = {
                    top: value[0],
                    right: value[1],
                    bottom: value[0],
                    left: value[1],
                };
            }
            else if (value.length === 1) {
                value = value[0];
            }
            else {
                value = defaultVal;
            }
        }
        else if (typeof value === 'object') {
            res.top = (_a = value.top) !== null && _a !== void 0 ? _a : defaultVal;
            res.right = (_b = value.right) !== null && _b !== void 0 ? _b : defaultVal;
            res.bottom = (_c = value.bottom) !== null && _c !== void 0 ? _c : defaultVal;
            res.left = (_d = value.left) !== null && _d !== void 0 ? _d : defaultVal;
        }
        if (typeof value === 'number') {
            res.top = value;
            res.right = value;
            res.bottom = value;
            res.left = value;
        }
        return res;
    }
    function parseOptions(raw, doc) {
        var settings = getSettings(raw);
        var _a = doc.internal, scaleFactor = _a.scaleFactor, pageSize = _a.pageSize;
        var margin = parseSpacing(settings.margin, 40 / scaleFactor);
        var startY = typeof settings.startY === 'number' ? settings.startY : null;
        var startX = typeof settings.startX === 'number' ? settings.startX : null;
        var showHead = settings.showHead;
        var showFoot = settings.showFoot;
        var defaultStyles$1 = defaultStyles(scaleFactor);
        var theme = getTheme(settings.theme, doc);
        var styles = getStyles([
            defaultStyles$1,
            theme ? theme.table : {},
            settings.styles,
        ], doc);
        var headStyles = getStyles([
            defaultStyles$1,
            theme ? theme.table : {},
            theme ? theme.head : {},
            settings.styles,
            settings.headStyles,
        ], doc);
        var bodyStyles = getStyles([
            defaultStyles$1,
            theme ? theme.table : {},
            theme ? theme.body : {},
            settings.styles,
            settings.bodyStyles,
        ], doc);
        var footStyles = getStyles([
            defaultStyles$1,
            theme ? theme.table : {},
            theme ? theme.foot : {},
            settings.styles,
            settings.footStyles,
        ], doc);
        var alternateRowStyles = getStyles([
            defaultStyles$1,
            theme ? theme.table : {},
            theme ? theme.alternateRow : {},
            settings.styles,
            settings.alternateRowStyles,
        ], doc);
        var columnStyles = {};
        var colStyles = settings.columnStyles || {};
        var dataKeys = Object.keys(colStyles);
        for (var _i = 0, dataKeys_1 = dataKeys; _i < dataKeys_1.length; _i++) {
            var dataKey = dataKeys_1[_i];
            var specificStyles = getStyles([
                defaultStyles$1,
                theme ? theme.table : {},
                settings.styles,
                colStyles[dataKey],
            ], doc);
            columnStyles[dataKey] = specificStyles;
        }
        // hooks
        var didParseCell = settings.didParseCell, willDrawCell = settings.willDrawCell, didDrawCell = settings.didDrawCell, didDrawPage = settings.didDrawPage;
        var hooks = {
            didParseCell: [],
            willDrawCell: [],
            didDrawCell: [],
            didDrawPage: [],
            addPage: [],
            afterNewPage: [],
        };
        if (didParseCell)
            hooks.didParseCell.push(didParseCell);
        if (willDrawCell)
            hooks.willDrawCell.push(willDrawCell);
        if (didDrawCell)
            hooks.didDrawCell.push(didDrawCell);
        if (didDrawPage)
            hooks.didDrawPage.push(didDrawPage);
        return {
            // Deprecated
            // TODO remove in next major
            continueNewPage: settings.continueNewPage,
            // Parsed options
            pageBreak: settings.pageBreak,
            rowPageBreak: settings.rowPageBreak,
            margin: margin,
            startY: startY,
            startX: startX,
            showHead: showHead,
            showFoot: showFoot,
            tableWidth: settings.tableWidth,
            styles: styles,
            headStyles: headStyles,
            bodyStyles: bodyStyles,
            footStyles: footStyles,
            alternateRowStyles: alternateRowStyles,
            columnStyles: columnStyles,
            // Hooks
            hooks: hooks,
        };
    }

    /**
     * Create models from the user input
     *
     * @param input
     * @param options
     * @param doc
     * @returns {Table}
     */
    function createTable(input, options, doc) {
        var settings = options;
        var head = parseSection(input.head, settings.headStyles, 'head', settings, doc);
        var body = parseSection(input.body, settings.bodyStyles, 'body', settings, doc);
        var foot = parseSection(input.foot, settings.footStyles, 'foot', settings, doc);
        var columns = parseColumns(input, options);
        var hooks = parseHooks(settings, options.hooks);
        var table = new Table(input.tableId, settings, hooks, head, body, foot, columns);
        return table;
    }
    function parseColumns(input, options) {
        var columns = [];
        if (input.columns) {
            columns = input.columns.map(function (input, index) {
                var dataKey = input.dataKey || input;
                return new Column(dataKey, input, index);
            });
        }
        else if (input.head.length > 0 || input.body.length > 0) {
            var dataKeys = Object.keys(input.head[0] || input.body[0] || {});
            columns = dataKeys.map(function (key, index) { return new Column(key, key, index); });
        }
        var columnStyles = options.columnStyles;
        columns.forEach(function (col) {
            var colStyles = columnStyles[col.dataKey] ||
                columnStyles[col.index] ||
                {};
            var cellWidth = colStyles.cellWidth;
            if (cellWidth) {
                col.width = cellWidth;
            }
        });
        return columns;
    }
    function parseHooks(settings, userHooks) {
        // Merge hooks with user options
        var hooks = {
            didParseCell: [],
            willDrawCell: [],
            didDrawCell: [],
            didDrawPage: [],
            addPage: [],
            afterNewPage: [],
        };
        hooks = __assign(__assign({}, hooks), userHooks);
        if (settings.didParseCell)
            hooks.didParseCell.push(settings.didParseCell);
        if (settings.willDrawCell)
            hooks.willDrawCell.push(settings.willDrawCell);
        if (settings.didDrawCell)
            hooks.didDrawCell.push(settings.didDrawCell);
        if (settings.didDrawPage)
            hooks.didDrawPage.push(settings.didDrawPage);
        return hooks;
    }
    function parseSection(sectionInput, styles, section, settings, doc) {
        var sectionRows = [];
        if (sectionInput.length === 0 && section === 'body') {
            // We need to have at least one body row in order to know the columns
            // if no columns are set.
            sectionRows.push(new Row([], -1, section, {}, new Map()));
        }
        sectionInput.forEach(function (rawRow, index) {
            var row = parseRow(rawRow, index, styles, section, settings, doc);
            if (row) {
                sectionRows.push(row);
            }
        });
        return sectionRows;
    }
    function parseRow(rawRow, index, rowStyles, section, settings, doc) {
        if (!rawRow) {
            return null;
        }
        var row = new Row(rawRow, index, section, {}, new Map());
        for (var i = 0; i < doc.columns.length; i++) {
            var col = doc.columns[i];
            var rawCell = rawRow[col.dataKey] || rawRow[i] || '';
            var styles = getStyles([
                settings.styles,
                section === 'body' && settings.bodyStyles,
                section === 'head' && settings.headStyles,
                section === 'foot' && settings.footStyles,
                rowStyles,
                (index % 2 === 0 &&
                    section === 'body' &&
                    settings.alternateRowStyles) ||
                    {},
                (settings.columnStyles || {})[col.dataKey] ||
                    (settings.columnStyles || {})[col.index] ||
                    {},
            ], doc);
            var cell = new Cell(rawCell, styles, section);
            // Workaround for cells not having a width by default
            cell.width = (doc.columns[i].width || 0);
            row.cells[i] = cell;
            var didParseCellHooks = settings.hooks.didParseCell;
            var didParseCellData = new CellHookData(cell, row, col, doc);
            if (didParseCellHooks) {
                for (var _i = 0, didParseCellHooks_1 = didParseCellHooks; _i < didParseCellHooks_1.length; _i++) {
                    var hook = didParseCellHooks_1[_i];
                    hook(didParseCellData);
                }
            }
        }
        return row;
    }

    /**
     * Calculate the width of each column in the table
     */
    function calculateWidths(doc, table) {
        var tableWidth = table.settings.tableWidth;
        var pageWidth = doc.internal.pageSize.width;
        var margin = table.settings.margin;
        var marginX = margin.left + margin.right;
        var preferredTableWidth = 0;
        if (typeof tableWidth === 'number') {
            preferredTableWidth = tableWidth;
        }
        else if (tableWidth === 'wrap') {
            preferredTableWidth = table.columns.reduce(function (acc, col) { return acc + col.wrappedWidth; }, 0);
        }
        else {
            preferredTableWidth = pageWidth - marginX;
        }
        table.width = preferredTableWidth;
        var minWidth = 0;
        var minDiff = 0;
        var autoWidth = 0;
        var autoDiff = 0;
        for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {
            var column = _a[_i];
            var customWidth = column.getMaxCustomCellWidth(table);
            column.minReadableWidth = doc.getStringUnitWidth(column.dataKey);
            // These are the two primary widths we later use to distribute the available table width
            column.minWidth = Math.max(column.minReadableWidth, customWidth);
            column.wrappedWidth = doc.getStringUnitWidth(column.dataKey);
            if (typeof column.width === 'number') {
                // Should not be changed
            }
            else if (column.width === 'wrap') {
                column.width = column.wrappedWidth;
                minWidth += column.width;
                autoWidth += column.width;
            }
            else {
                minWidth += column.minWidth;
                minDiff += column.minWidth;
                autoWidth += column.wrappedWidth;
                autoDiff += column.wrappedWidth;
            }
        }
        distributeWidth(table.columns, minWidth, minDiff, 'minWidth');
        distributeWidth(table.columns, autoWidth, autoDiff, 'wrappedWidth');
        applyColSpans(table);
        fitContent(table, doc);
        applyRowSpans(table);
    }
    function distributeWidth(columns, totalWidth, diffWidth, property) {
        for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
            var column = columns_1[_i];
            var isAuto = typeof column.width !== 'number' && column.width !== 'wrap';
            if (isAuto && totalWidth > 0) {
                column.width = column[property] + (diffWidth * (column[property] / totalWidth));
            }
        }
    }
    function applyRowSpans(table) {
        var rowSpanCells = {};
        var colRowSpansLeft = {};
        var all = table.allRows();
        for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {
            var row = all[rowIndex];
            for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {
                var column = _a[_i];
                var cell = row.cells[column.index];
                if (!cell)
                    continue;
                if (colRowSpansLeft[column.index] > 0) {
                    cell.spanned = true;
                    colRowSpansLeft[column.index]--;
                    continue;
                }
                if (cell.rowSpan > 1) {
                    rowSpanCells[column.index] = {
                        cell: cell,
                        left: cell.rowSpan - 1,
                        row: row,
                    };
                    colRowSpansLeft[column.index] = cell.rowSpan - 1;
                }
                else if (rowSpanCells[column.index]) {
                    var cellHeight = rowSpanCells[column.index].cell.height;
                    cellHeight += row.getHeight(table.columns);
                    rowSpanCells[column.index].cell.height = cellHeight;
                }
            }
            // After every row, check if any of the row spans are finished
            for (var _b = 0, _c = Object.keys(colRowSpansLeft); _b < _c.length; _b++) {
                var colIndex = _c[_b];
                var index = parseInt(colIndex);
                if (colRowSpansLeft[index] === 0) {
                    delete colRowSpansLeft[index];
                    var rowSpanCell = rowSpanCells[index].cell;
                    var rowSpanRow = rowSpanCells[index].row;
                    var remainingRows = all.slice(rowIndex + 1);
                    var nextRow = remainingRows.find(function (r) { return r.cells[index]; });
                    if (nextRow) {
                        var nextCell = nextRow.cells[index];
                        if (nextCell) {
                            var y = rowSpanCell.y + rowSpanCell.height;
                            var height = y - nextCell.y;
                            rowSpanCell.height = height;
                        }
                    }
                }
            }
        }
    }
    function applyColSpans(table) {
        var all = table.allRows();
        for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {
            var row = all[rowIndex];
            var colSpansLeft = 0;
            var masterCell_1 = null;
            for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {
                var column = _a[_i];
                var cell = row.cells[column.index];
                if (colSpansLeft > 1 && cell) {
                    colSpansLeft--;
                    cell.spanned = true;
                    if (masterCell_1) {
                        masterCell_1.width += cell.width;
                    }
                    continue;
                }
                else {
                    colSpansLeft = 0;
                    masterCell_1 = null;
                }
                if (cell) {
                    if (cell.colSpan > 1) {
                        colSpansLeft = cell.colSpan;
                        masterCell_1 = cell;
                    }
                }
            }
        }
    }
    function fitContent(table, doc) {
        var cellPadding = 0;
        var FONT_ROW_RATIO = 1.15;
        // Calculate cell padding and content width
        for (var _i = 0, _a = table.allRows(); _i < _a.length; _i++) {
            var row = _a[_i];
            for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {
                var column = _c[_b];
                var cell = row.cells[column.index];
                if (!cell)
                    continue;
                applyStyles(cell.styles);
                var padding = cell.padding('horizontal');
                cell.contentWidth = cell.width - padding;
                if (typeof cell.styles.cellWidth === 'number') {
                    cell.minReadableWidth = cell.styles.cellWidth;
                    cell.contentWidth = cell.styles.cellWidth - padding;
                }
                var text = Array.isArray(cell.text) ? cell.text : [cell.text];
                // In this case the text is not an array of strings, but a string.
                if (!Array.isArray(text)) {
                    text = [text];
                }
                // If the cell has a width, we need to calculate the wrapped text.
                var k = doc.internal.scaleFactor;
                cell.text = doc.splitTextToSize(text, cell.contentWidth, {
                    fontSize: cell.styles.fontSize,
                });
                var lineCount = cell.text.length;
                if (Array.isArray(cell.text)) {
                    lineCount = cell.text.length;
                }
                cell.contentWidth = doc.getStringUnitWidth(cell.text, {
                    font: doc.getFont(),
                    fontSize: cell.styles.fontSize,
                });
                var height = lineCount * cell.styles.fontSize * FONT_ROW_RATIO;
                var verticalPadding = cell.padding('vertical');
                cell.height = height + verticalPadding;
            }
        }
        // Calculate row height
        for (var _d = 0, _e = table.allRows(); _d < _e.length; _d++) {
            var row = _e[_d];
            var maxCellHeight = 0;
            for (var _f = 0, _g = table.columns; _f < _g.length; _f++) {
                var column = _g[_f];
                var cell = row.cells[column.index];
                if (cell && !cell.spanned) {
                    if (cell.height > maxCellHeight) {
                        maxCellHeight = cell.height;
                    }
                }
            }
            row.height = maxCellHeight;
        }
    }

    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function drawTable(table, doc) {
        var settings = table.settings;
        var startY = settings.startY, margin = settings.margin;
        var cursor = {
            x: margin.left,
            y: startY,
        };
        var sectionsHeight = table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);
        var minTableBottomPos = startY + margin.bottom + sectionsHeight;
        if (settings.pageBreak === 'avoid') {
            var spaceLeft = doc.internal.pageSize.height - minTableBottomPos;
            var bodyHeight = table.body.reduce(function (acc, row) { return acc + row.height; }, 0);
            if (bodyHeight > spaceLeft) {
                var _a = table.hooks, addPage = _a.addPage;
                callPageHooks(doc, table, addPage, cursor);
                cursor.y = margin.top;
            }
        }
        var pageContent = {
            height: 0,
            width: 0,
            rows: [],
        };
        // let pageCount = 1;
        var ancher = { x: cursor.x, y: cursor.y };
        table.pageStartX = ancher.x;
        table.pageStartY = ancher.y;
        var _loop_1 = function (row) {
            cursor.x = margin.left;
            var pageHeight = doc.internal.pageSize.height;
            var pageContentHeight = pageHeight - margin.bottom;
            var isNewPage = cursor.y + row.height + margin.bottom > pageHeight;
            if (isNewPage) {
                var _b = table.hooks, addPage = _b.addPage;
                callPageHooks(doc, table, addPage, cursor);
                // pageCount = 1
                cursor.y = margin.top;
                ancher.y = cursor.y;
            }
            row.y = cursor.y;
            row.x = cursor.x;
            var _loop_2 = function (column) {
                var cell = row.cells[column.index];
                if (!cell) {
                    return "continue";
                }
                applyStyles(cell.styles);
                cell.x = cursor.x;
                cell.y = cursor.y;
                var textPos = {
                    x: cell.x + cell.padding('left'),
                    y: cell.y + cell.padding('top'),
                };
                cell.textPos = textPos;
                var _c = table.hooks, willDrawCell = _c.willDrawCell;
                if (willDrawCell) {
                    for (var _i = 0, willDrawCell_1 = willDrawCell; _i < willDrawCell_1.length; _i++) {
                        var hook = willDrawCell_1[_i];
                        if (hook(new CellHookData(cell, row, column, doc)) === false) {
                            cursor.x += column.width;
                            return "continue";
                        }
                    }
                }
                var fillStyle = getFillStyle(cell.styles);
                if (fillStyle) {
                    doc.rect(cell.x, cell.y, cell.width, cell.height, 'F');
                }
                var i = 0;
                // drawBorders(cell, { start: true })
                for (var _d = 0, _e = cell.text; _d < _e.length; _d++) {
                    var line = _e[_d];
                    var halign = cell.styles.halign;
                    var valign = cell.styles.valign;
                    var x = textPos.x;
                    var y = textPos.y + i * cell.styles.fontSize * FONT_ROW_RATIO;
                    var lineBreaks = getlog2(line.length - 1);
                    var isLineBreak = (cell.styles.overflow === 'linebreak' && line.length > 1) ||
                        (Array.isArray(cell.text) && i > 0);
                    if (isLineBreak) {
                        y += cell.styles.fontSize * FONT_ROW_RATIO;
                    }
                    var text = line;
                    if (valign === 'top') {
                        // Default
                    }
                    else if (valign === 'bottom') {
                        y += cell.height - cell.text.length * cell.styles.fontSize * FONT_ROW_RATIO;
                    }
                    else if (valign === 'middle') {
                        y +=
                            cell.height / 2 -
                                (cell.text.length * cell.styles.fontSize * FONT_ROW_RATIO) / 2;
                    }
                    if (halign === 'right') {
                        x += cell.width - cell.padding('horizontal');
                    }
                    else if (halign === 'center') {
                        x += cell.width / 2;
                    }
                    // Write text to doc
                    var textOptions = {
                        align: halign,
                        baseline: valign,
                        maxWidth: cell.contentWidth,
                    };
                    doc.text(text, x, y, textOptions);
                    i++;
                }
                var _f = table.hooks, didDrawCell = _f.didDrawCell;
                if (didDrawCell) {
                    for (var _g = 0, didDrawCell_1 = didDrawCell; _g < didDrawCell_1.length; _g++) {
                        var hook = didDrawCell_1[_g];
                        hook(new CellHookData(cell, row, column, doc));
                    }
                }
                cursor.x += column.width;
            };
            for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {
                var column = _a[_i];
                _loop_2(column);
            }
            cursor.y += row.height;
            pageContent.rows.push(row);
        };
        for (var _i = 0, _b = table.allRows(); _i < _b.length; _i++) {
            var row = _b[_i];
            _loop_1(row);
        }
        var i = 0;
        for (var _c = 0, _d = table.allRows(); _c < _d.length; _c++) {
            var row = _d[_c];
            var j = 0;
            for (var _e = 0, _f = table.columns; _e < _f.length; _e++) {
                var column = _f[_e];
                var cell = row.cells[column.index];
                drawBorders(cell, {
                    start: j === 0,
                    end: j === table.columns.length - 1,
                });
                j++;
            }
            i++;
        }
        var _g = table.hooks, didDrawPage = _g.didDrawPage;
        if (didDrawPage) {
            for (var _h = 0, didDrawPage_1 = didDrawPage; _h < didDrawPage_1.length; _h++) {
                var hook = didDrawPage_1[_h];
                hook(new PageHookData(doc, table, cursor));
            }
        }
        setLastTable(table);
    }

    /**
     * Improved text function with halign and valign support
     * Inspiration from: http://stackoverflow.com/questions/28327510/align-text-right-using-jspdf/28433113#28433113
     */
    function autoTableText(text, x, y, styles) {
        styles = styles || {};
        var FONT_ROW_RATIO = 1.15;
        var doc = getDocument();
        var S = doc.internal.scaleFactor;
        var k = doc.internal.scaleFactor;
        var fontSize = doc.getFontSize() / k;
        var align = styles.align || 'left';
        var valign = styles.baseline || 'top';
        var lineheight = styles.lineHeightFactor || FONT_ROW_RATIO;
        var maxWidth = styles.maxWidth || 0;
        var shouldJustify = styles.justify || false;
        var str = text;
        if (typeof text !== 'string') {
            if (text.length > 1) {
                // The first line is used to determine the horizontal alignment
                var firstLine = text[0];
                var remainingLines = text.slice(1);
                autoTableText(firstLine, x, y, styles);
                // The remaining lines are aligned based on the first line
                styles.align = 'left';
                var nextY = y + fontSize * lineheight;
                autoTableText(remainingLines, x, nextY, styles);
                return;
            }
            else {
                str = text[0];
            }
        }
        if (maxWidth > 0) {
            var leading = styles.leading || undefined;
            var charSpace = styles.charSpace || undefined;
            var parts = str.split(' ');
            var line = [];
            var lines = [];
            for (var i = 0; i < parts.length; i++) {
                var part = parts[i];
                line.push(part);
                var lineWithNext = line.join(' ');
                var width = doc.getStringUnitWidth(lineWithNext, {
                    leading: leading,
                    charSpace: charSpace,
                    fontSize: fontSize,
                }) * fontSize;
                if (width > maxWidth) {
                    line.pop();
                    lines.push(line.join(' '));
                    line = [part];
                }
            }
            lines.push(line.join(' '));
            str = lines;
        }
        if (typeof str === 'string') {
            str = str.split(/\r\n|\r|\n/g);
        }
        var xOffset = styles.xOffset || 0;
        var yOffset = styles.yOffset || 0;
        var R2D = 180 / Math.PI;
        if (styles.angle) {
            styles.angle = styles.angle * (Math.PI / 180);
            var x_1 = x, y_1 = y;
            var angle = styles.angle;
            var x_2 = x_1 * Math.cos(angle) - y_1 * Math.sin(angle);
            var y_2 = x_1 * Math.sin(angle) + y_1 * Math.cos(angle);
            x = x_2;
            y = y_2;
        }
        // Printing lines with all alignments, justification works only for left align
        var w, i;
        var an;
        var leading = styles.leading || undefined;
        var charSpace = styles.charSpace || undefined;
        var normalCharSpace = doc.getCharSpace();
        if (shouldJustify) {
            // Modify char space and return to normal after printing
            var justify = function (line, width) {
                if (styles.charSpace) {
                    doc.setCharSpace(styles.charSpace);
                }
                var cs = doc.getCharSpace();
                var wordCount = line.split(' ').length;
                if (width > 0 && wordCount > 1) {
                    var space = (width - doc.getStringUnitWidth(line, { charSpace: cs })) / (wordCount - 1);
                    doc.setCharSpace(cs + space);
                }
            };
            for (i = 0; i < str.length; i++) {
                if (i > 0) {
                    // Reset char space for the new line
                    if (styles.charSpace) {
                        doc.setCharSpace(styles.charSpace);
                    }
                    else {
                        doc.setCharSpace(normalCharSpace);
                    }
                }
                var line = str[i];
                var width = doc.getStringUnitWidth(line, { charSpace: doc.getCharSpace() }) * fontSize;
                var lastLine = i === str.length - 1;
                // Don't justify the last line
                if (lastLine) {
                    doc.text(line, x, y);
                }
                else {
                    justify(line, maxWidth);
                    doc.text(line, x, y);
                }
                y += fontSize * lineheight;
            }
        }
        else {
            for (i = 0; i < str.length; i++) {
                an = 0; //print anchor = 0 starting from left of the text, but not from the left of the page
                w =
                    doc.getStringUnitWidth(str[i], {
                        leading: leading,
                        charSpace: charSpace,
                    }) * fontSize;
                if (align === 'right') {
                    an = w;
                }
                else if (align === 'center') {
                    an = w / 2;
                }
                var h = fontSize;
                if (valign === 'bottom') {
                    h = -fontSize * (str.length - i - 1);
                }
                else if (valign === 'middle') {
                    h =
                        -fontSize * (str.length / 2 - i) +
                            (styles.lineHeightFactor / 2) * fontSize;
                }
                // The angle is relative to the current rotation, if any.
                if (styles.angle) {
                    var y_3 = y, x_3 = x;
                    var angle = styles.angle;
                    var _a = doc.internal.getCurrentPage(), P = _a.P, H = _a.H, W = _a.W, O = _a.O;
                    // TODO This is wrong, but it's what jspdf does.
                    var sx = 1;
                    var sy = 1;
                    if (P === 90 || P === 270) {
                        var tmp = sx;
                        sx = sy;
                        sy = tmp;
                    }
                    if (P === 90) {
                        y_3 = H - y_3;
                        x_3 = x_3;
                    }
                    else if (P === 180) {
                        y_3 = H - y_3;
                        x_3 = W - x_3;
                    }
                    else if (P === 270) {
                        y_3 = y_3;
                        x_3 = W - x_3;
                    }
                    var line = str[i];
                    var _b = doc.getTextDimensions(line), width = _b.w, height = _b.h;
                    var lineX = x_3 - an;
                    var lineY = y_3 + h;
                    // Translate to the origin of the text
                    var tx = x, ty = y;
                    doc.internal.write('q');
                    doc.internal.write("".concat(Math.cos(angle), " ").concat(Math.sin(angle), " ").concat(-Math.sin(angle), " ").concat(Math.cos(angle), " ").concat(tx.toFixed(2), " ").concat(ty.toFixed(2), " cm"));
                    // Rotate the text
                    doc.internal.write('BT');
                    // doc.internal.write(`/F1 ${fontSize} Tf`);
                    doc.internal.write('1 0 0 1 0 0 Tm');
                    doc.text(str[i], -an, h, {
                        leading: leading,
                        charSpace: charSpace,
                        lang: styles.lang,
                    });
                    doc.internal.write('ET');

                    doc.internal.write('Q');
                    doc.internal.write('q');
                    doc.internal.write("".concat(Math.cos(0), " ").concat(Math.sin(0), " ").concat(-Math.sin(0), " ").concat(Math.cos(0), " ").concat(tx.toFixed(2), " ").concat(ty.toFixed(2), " cm"));
                    doc.internal.write('Q');
                }
                else {
                    doc.text(str[i], x - an, y + h, {
                        leading: leading,
                        charSpace: charSpace,
                        lang: styles.lang,
                    });
                }
                y += fontSize * lineheight;
            }
        }
        if (styles.charSpace) {
            doc.setCharSpace(normalCharSpace);
        }
    }

    // Helper functions
    function parseContent(input) {
        var head = input.head || [];
        var body = input.body || [];
        var foot = input.foot || [];
        var columns = input.columns || [];
        if (input.html) {
            var el = input.html;
            if (typeof el === 'string') {
                el = document.querySelector(el);
            }
            if (el) {
                var res = parseHtml(el, input.includeHiddenHtml, input.useCss);
                head = res.head;
                body = res.body;
                columns = res.columns;
            }
        }
        return {
            head: head,
            body: body,
            foot: foot,
            columns: columns,
            tableId: input.tableId,
        };
    }
    function parseHtml(tableElement, includeHiddenHtml, useCss) {
        var _a, _b, _c;
        if (includeHiddenHtml === void 0) { includeHiddenHtml = false; }
        if (useCss === void 0) { useCss = false; }
        var head = [], body = [], foot = [];
        var columns = [];
        if (!tableElement) {
            console.error('Html table could not be found with input:', tableElement);
            return { head: head, body: body, columns: columns };
        }
        // Columns and lines
        var firstRow = ((_c = (_b = (_a = tableElement.rows) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.cells) !== null && _c !== void 0 ? _c : [];
        for (var i = 0; i < firstRow.length; i++) {
            var cell = firstRow[i];
            var val = cell.textContent || '';
            var style = window.getComputedStyle(cell);
            if (useCss && style) {
                columns.push({
                    dataKey: i,
                    title: val,
                    styles: parseCssStyles(style, getDoc()),
                });
            }
            else {
                columns.push({ dataKey: i, title: val });
            }
        }
        var sections = {
            THEAD: head,
            TBODY: body,
            TFOOT: foot,
        };
        for (var i = 0; i < tableElement.rows.length; i++) {
            var row = tableElement.rows[i];
            var style = window.getComputedStyle(row);
            if (!includeHiddenHtml && style.display === 'none') {
                continue;
            }
            var section = sections[row.parentElement.tagName];
            if (!section) {
                console.error('Unrecognized table section: ' + row.parentElement.tagName);
                continue;
            }
            var rowContent = [];
            for (var j = 0; j < row.cells.length; j++) {
                var cell = row.cells[j];
                var style_1 = window.getComputedStyle(cell);
                var content = {
                    content: cell.textContent || '',
                    rowSpan: cell.rowSpan,
                    colSpan: cell.colSpan,
                };
                if (useCss && style_1) {
                    content.styles = parseCssStyles(style_1, getDoc());
                }
                rowContent.push(content);
            }
            if (rowContent.length > 0) {
                section.push(rowContent);
            }
        }
        return { head: head, body: body, columns: columns };
    }

    /**
     * This is the real `autoTable` function which is called by the
     * higher level `autoTable` function. It defined in this file to
     * avoid circular dependencies.
     */
    function autoTable(options) {
        var doc = getDoc();
        var userOptions = options;
        var input = parseContent(userOptions);
        var _a = parseOptions(userOptions, doc), hooks = _a.hooks, styles = _a.styles, headStyles = _a.headStyles, bodyStyles = _a.bodyStyles, footStyles = _a.footStyles, alternateRowStyles = _a.alternateRowStyles, columnStyles = _a.columnStyles, margin = _a.margin, startY = _a.startY, tableWidth = _a.tableWidth, showHead = _a.showHead, showFoot = _a.showFoot, continueNewPage = _a.continueNewPage, pageBreak = _a.pageBreak, rowPageBreak = _a.rowPageBreak;
        var startYVal = startY !== null && startY !== void 0 ? startY : 0;
        var table = createTable(input, {
            // Deprecated
            continueNewPage: continueNewPage,
            // Parsed options
            pageBreak: pageBreak,
            rowPageBreak: rowPageBreak,
            margin: margin,
            startY: startYVal,
            tableWidth: tableWidth,
            showHead: showHead,
            showFoot: showFoot,
            styles: styles,
            headStyles: headStyles,
            bodyStyles: bodyStyles,
            footStyles: footStyles,
            alternateRowStyles: alternateRowStyles,
            columnStyles: columnStyles,
            // Hooks
            hooks: hooks,
        }, doc);
        var cursor = {
            x: table.settings.margin.left,
            y: startYVal,
        };
        calculateWidths(doc, table);
        var pageContent = {
            height: 0,
            width: 0,
            rows: [],
        };
        addContent(doc, table, cursor, pageContent);
        setLastTable(table);
        var userStyles = getGlobal().userStyles;
        doc.setFontSize(userStyles.fontSize);
        doc.setFont(userStyles.font, userStyles.fontStyle);
        return table;
    }

    // export { applyPlugin } from './applyPlugin'
    